/**
 * Code generation templates for route files
 */

export function getHeaderComment(): string {
  return `// Auto-generated by next-typed-codegen-route. Do not edit.
// Generated at: ${new Date().toISOString()}
`;
}

// ============================================
// Init Templates (Static files - generated once)
// ============================================

/**
 * Template for route-meta.ts (init)
 */
export function routeMetaTemplate(): string {
  return `${getHeaderComment()}
import type { JSX } from "react";

/**
 * Scanned route information (used by codegen)
 */
export interface ScannedRoute {
  /** Absolute file path */
  filePath: string;
  /** Route path (e.g., /test/[id]) */
  routePath: string;
  /** Dynamic parameter names (e.g., ["id"]) */
  params: string[];
  /** Whether this is a static route */
  isStatic: boolean;
}

/**
 * Codegen configuration
 */
export interface RouteCodegenConfig {
  /**
   * Path exclusion filter
   * Returns true to exclude the path from scanning
   *
   * @example
   * excludePath: (path) => path.includes("/@")
   */
  excludePath?: (path: string) => boolean;

  /**
   * Route sorting function
   * @example
   * sortRoutes: (a, b) => a.routePath.localeCompare(b.routePath)
   */
  sortRoutes?: (a: ScannedRoute, b: ScannedRoute) => number;

  /**
   * Output directory for generated files
   * Default: ".generated/next-typed-codegen-route"
   *
   * @example
   * outputDir: "src/generated/routes"
   */
  outputDir?: string;

  /**
   * App directory path to scan
   * Default: "src/app"
   */
  appDir?: string;
}

/**
 * Route codegen config helper
 */
export function createRouteConfig(config: RouteCodegenConfig): RouteCodegenConfig {
  return config;
}

/**
 * Route metadata
 * Extend this interface to add custom metadata to your routes
 *
 * @example
 * // In a .d.ts file or at the top of your route file:
 * declare module "./.generated/routes" {
 *   interface RouteMeta {
 *     title?: string;
 *     description?: string;
 *   }
 * }
 */
// biome-ignore lint/suspicious/noEmptyInterface: Extensible via declare module
export interface RouteMeta {}

/**
 * Convert all object values to string
 */
export type StringifyValues<T> = {
  [K in keyof T]: string;
};

/**
 * SearchParams validator type
 */
export type SearchParamsValidator<TSearchParams> = (
  searchParams: Record<string, string | string[] | undefined>,
) => Promise<TSearchParams> | TSearchParams;

/**
 * Params validator type
 */
export type ParamsValidator<TParams> = (
  params: Record<string, string>,
) => Promise<TParams> | TParams;

/**
 * Static route validator (searchParams only)
 */
export interface StaticRouteValidator<TSearchParams> {
  searchParams: SearchParamsValidator<TSearchParams>;
}

/**
 * Dynamic route validator (params required, searchParams optional)
 */
export interface DynamicRouteValidator<TParams, TSearchParams = never> {
  params: ParamsValidator<TParams>;
  searchParams?: TSearchParams extends never
    ? never
    : SearchParamsValidator<TSearchParams>;
}

/**
 * Server component type (async)
 */
export type ServerComponent<TProps> = (props: TProps) => Promise<JSX.Element>;

/**
 * Client component type
 */
export type ClientComponent<TProps> = (props: TProps) => JSX.Element;

// ============================================
// Static Route Options
// ============================================

/**
 * Static route with validator
 */
export interface StaticRouteOptionsWithValidator<TSearchParams> {
  component:
    | ServerComponent<{ searchParams: Promise<TSearchParams> }>
    | ClientComponent<{ searchParams: Promise<TSearchParams> }>;
  validator: StaticRouteValidator<TSearchParams>;
  meta?: RouteMeta;
}

/**
 * Static route without validator
 */
export interface StaticRouteOptions {
  component: ServerComponent<object> | ClientComponent<object>;
  validator?: never;
  meta?: RouteMeta;
}

// ============================================
// Dynamic Route Options
// ============================================

/**
 * Dynamic route with validator
 */
export interface DynamicRouteOptionsWithValidator<TParams, TSearchParams = never> {
  component:
    | ServerComponent<{
        params: Promise<TParams>;
        searchParams?: TSearchParams extends never ? never : Promise<TSearchParams>;
      }>
    | ClientComponent<{
        params: Promise<TParams>;
        searchParams?: TSearchParams extends never ? never : Promise<TSearchParams>;
      }>;
  validator: DynamicRouteValidator<TParams, TSearchParams>;
  meta?: RouteMeta;
}

/**
 * Dynamic route without validator
 */
export interface DynamicRouteOptions<TParams> {
  component:
    | ServerComponent<{ params: Promise<StringifyValues<TParams>> }>
    | ClientComponent<{ params: Promise<StringifyValues<TParams>> }>;
  validator?: never;
  meta?: RouteMeta;
}
`;
}

/**
 * Template for create-route.ts (init)
 */
export function createRouteTemplate(): string {
  return `${getHeaderComment()}
import type {
  DynamicRouteOptions,
  DynamicRouteOptionsWithValidator,
  StaticRouteOptions,
  StaticRouteOptionsWithValidator,
  StringifyValues,
} from "./route-meta";

/**
 * Route config type (the options passed to createRoute/createDynamicRoute)
 */
export type RouteConfig =
  | StaticRouteOptions
  | StaticRouteOptionsWithValidator<unknown>
  | DynamicRouteOptions<unknown>
  | DynamicRouteOptionsWithValidator<unknown, unknown>;

/**
 * Route component type with attached config
 */
export type RouteComponent<P = object> = React.ComponentType<P> & {
  _routeConfig?: RouteConfig;
};

// ============================================
// createRoute - Static Routes
// ============================================

/**
 * Static route with validator
 */
export function createRoute<TSearchParams>(
  options: StaticRouteOptionsWithValidator<TSearchParams>,
): RouteComponent<{ searchParams: Promise<TSearchParams> }>;

/**
 * Static route without validator
 */
export function createRoute(options: StaticRouteOptions): RouteComponent;

/**
 * Create static route
 */
export function createRoute(
  options: StaticRouteOptionsWithValidator<unknown> | StaticRouteOptions,
  // biome-ignore lint/suspicious/noExplicitAny: Overload implementation signature
): RouteComponent<any> {
  const RouteComponent = options.component as RouteComponent;
  RouteComponent._routeConfig = options;
  return RouteComponent;
}

// ============================================
// createDynamicRoute - Dynamic Routes
// ============================================

/**
 * Dynamic route with validator
 */
export function createDynamicRoute<TParams, TSearchParams = never>(
  options: DynamicRouteOptionsWithValidator<TParams, TSearchParams>,
): RouteComponent<{
  params: Promise<TParams>;
  searchParams?: TSearchParams extends never ? never : Promise<TSearchParams>;
}>;

/**
 * Dynamic route without validator
 */
export function createDynamicRoute<TParams>(
  options: DynamicRouteOptions<TParams>,
): RouteComponent<{ params: Promise<StringifyValues<TParams>> }>;

/**
 * Create dynamic route
 */
export function createDynamicRoute(
  options: DynamicRouteOptionsWithValidator<unknown, unknown> | DynamicRouteOptions<unknown>,
  // biome-ignore lint/suspicious/noExplicitAny: Overload implementation signature
): RouteComponent<any> {
  const RouteComponent = options.component as RouteComponent;
  RouteComponent._routeConfig = options;
  return RouteComponent;
}
`;
}

/**
 * Template for utils.ts (init) - static utilities
 */
export function utilsStaticTemplate(): string {
  return `${getHeaderComment()}
import type { RouteConfig } from "./create-route";
import type {
  RouteHref,
  StaticRouteHref,
  DynamicRouteHref,
  RouteParamsMap,
} from "./types";
import { ROUTES, ROUTE_INFO, ROUTE_CONFIGS, DYNAMIC_ROUTE_PATTERNS } from "./routes";

// Re-export from routes.ts
export { ROUTES, ROUTE_INFO, ROUTE_CONFIGS, DYNAMIC_ROUTE_PATTERNS };

/** Route info (static data) */
export type RouteInfo<T extends RouteHref> = T extends DynamicRouteHref
  ? {
      href: T;
      isStatic: false;
      params: (keyof RouteParamsMap[T])[];
    }
  : {
      href: T;
      isStatic: true;
      params: [];
    };

/** Route info with config included */
export type FullRouteInfo<T extends RouteHref> = RouteInfo<T> & {
  config: RouteConfig | undefined;
};

/** Route options */
export interface RouteOptions {
  /** Load config dynamically (default: true) */
  dynamic?: boolean;
}

/** Route info from pathname matching (with extracted param values) */
export type PathnameRouteInfo<T extends RouteHref> = T extends DynamicRouteHref
  ? {
      href: T;
      isStatic: false;
      params: RouteParamsMap[T];
    }
  : {
      href: T;
      isStatic: true;
      params: Record<string, string>;
    };

/** Route info from pathname matching with config */
export type FullPathnameRouteInfo<T extends RouteHref> = PathnameRouteInfo<T> & {
  config: RouteConfig | undefined;
};

/**
 * Type-safe path builder
 *
 * @example
 * // Static route
 * path("/about")
 * // => "/about"
 *
 * // Dynamic route
 * path("/user/[id]", { id: "123" })
 * // => "/user/123"
 */
export function path<T extends StaticRouteHref>(route: T): string;
export function path<T extends DynamicRouteHref>(
  route: T,
  params: RouteParamsMap[T]
): string;
export function path(route: RouteHref, params?: Record<string, string>): string {
  if (!params) return route;

  return route.replace(/\\[([^\\]]+)\\]/g, (_, key) => {
    const value = params[key];
    if (value === undefined) {
      throw new Error(\`Missing param: \${key} for route: \${route}\`);
    }
    return encodeURIComponent(value);
  });
}

/**
 * Find matching dynamic route pattern from actual URL path
 *
 * @example
 * matchDynamicRoute("/user/123")
 * // => "/user/[id]"
 */
export function matchDynamicRoute(pathname: string): DynamicRouteHref | null {
  for (const { pattern, href } of DYNAMIC_ROUTE_PATTERNS) {
    if (pattern.test(pathname)) {
      return href;
    }
  }
  return null;
}

/**
 * Extract dynamic parameters from actual URL path
 *
 * @example
 * extractParams("/user/123", "/user/[id]")
 * // => { id: "123" }
 */
export function extractParams(
  pathname: string,
  pattern: DynamicRouteHref
): Record<string, string> | null {
  const patternEntry = DYNAMIC_ROUTE_PATTERNS.find((p) => p.href === pattern);
  if (!patternEntry) return null;

  const match = pathname.match(patternEntry.pattern);
  if (!match) return null;

  const paramKeys = pattern.match(/\\[([^\\]]+)\\]/g);
  if (!paramKeys) return {};

  const result: Record<string, string> = {};
  paramKeys.forEach((key, index) => {
    const paramName = key.slice(1, -1);
    result[paramName] = decodeURIComponent(match[index + 1]);
  });

  return result;
}

/**
 * Get all available routes
 *
 * @example
 * // With config (default, async)
 * await getAllRoutes()
 * // => [{ href: "/", isStatic: true, params: [], config: {...} }, ...]
 *
 * // Without config (sync)
 * getAllRoutes({ dynamic: false })
 * // => [{ href: "/", isStatic: true, params: [] }, ...]
 */
export function getAllRoutes(options?: { dynamic?: true }): Promise<FullRouteInfo<RouteHref>[]>;
export function getAllRoutes(options: { dynamic: false }): RouteInfo<RouteHref>[];
export function getAllRoutes(options: RouteOptions = {}): Promise<FullRouteInfo<RouteHref>[]> | RouteInfo<RouteHref>[] {
  const { dynamic = true } = options;

  if (!dynamic) {
    return ROUTES.map((href) => ROUTE_INFO[href] as RouteInfo<RouteHref>);
  }

  return Promise.all(
    ROUTES.map(async (href) => ({
      ...ROUTE_INFO[href],
      config: await ROUTE_CONFIGS[href](),
    } as FullRouteInfo<RouteHref>))
  );
}

/**
 * Get route by typed href
 *
 * @example
 * // With config (default, async)
 * await getRoute("/user/[id]")
 * // => { href: "/user/[id]", isStatic: false, params: ["id"], config: {...} }
 *
 * // Without config (sync)
 * getRoute("/user/[id]", { dynamic: false })
 * // => { href: "/user/[id]", isStatic: false, params: ["id"] }
 */
export function getRoute<T extends RouteHref>(href: T, options?: { dynamic?: true }): Promise<FullRouteInfo<T>>;
export function getRoute<T extends RouteHref>(href: T, options: { dynamic: false }): RouteInfo<T>;
export function getRoute<T extends RouteHref>(href: T, options: RouteOptions = {}): Promise<FullRouteInfo<T>> | RouteInfo<T> {
  const { dynamic = true } = options;

  if (!dynamic) {
    return ROUTE_INFO[href] as RouteInfo<T>;
  }

  return ROUTE_CONFIGS[href]().then((config) => ({
    ...ROUTE_INFO[href],
    config,
  } as FullRouteInfo<T>));
}

/**
 * Get route by actual pathname
 *
 * @example
 * // With config (default, async)
 * await getRouteByPathname("/user/123")
 * // => { href: "/user/[id]", isStatic: false, params: { id: "123" }, config: {...} }
 *
 * // Without config (sync)
 * getRouteByPathname("/user/123", { dynamic: false })
 * // => { href: "/user/[id]", isStatic: false, params: { id: "123" } }
 */
export function getRouteByPathname(pathname: string, options?: { dynamic?: true }): Promise<FullPathnameRouteInfo<RouteHref> | null>;
export function getRouteByPathname(pathname: string, options: { dynamic: false }): PathnameRouteInfo<RouteHref> | null;
export function getRouteByPathname(
  pathname: string,
  options: RouteOptions = {}
): Promise<FullPathnameRouteInfo<RouteHref> | null> | PathnameRouteInfo<RouteHref> | null {
  const { dynamic = true } = options;

  // Check static routes first (exact match)
  if (ROUTES.includes(pathname as RouteHref)) {
    const isDynamicRoute = pathname.includes("[");
    if (!isDynamicRoute) {
      const info: PathnameRouteInfo<StaticRouteHref> = {
        href: pathname as StaticRouteHref,
        isStatic: true,
        params: {},
      };

      if (!dynamic) return info;

      return ROUTE_CONFIGS[pathname as StaticRouteHref]().then((config) => ({
        ...info,
        config,
      }));
    }
  }

  // Check dynamic routes
  for (const { pattern, href } of DYNAMIC_ROUTE_PATTERNS) {
    const match = pathname.match(pattern);
    if (match) {
      const paramKeys = href.match(/\\[([^\\]]+)\\]/g);
      if (!paramKeys) continue;

      const params: Record<string, string> = {};
      paramKeys.forEach((key, index) => {
        const paramName = key.slice(1, -1);
        params[paramName] = decodeURIComponent(match[index + 1]);
      });

      const info = {
        href,
        isStatic: false,
        params,
      } as PathnameRouteInfo<RouteHref>;

      if (!dynamic) return info;

      return ROUTE_CONFIGS[href]().then((config) => ({
        ...info,
        config,
      }));
    }
  }

  return dynamic ? Promise.resolve(null) : null;
}
`;
}

/**
 * Template for index.ts (init)
 */
export function indexInitTemplate(): string {
  return `${getHeaderComment()}
// Types
export type {
  RouteHref,
  StaticRouteHref,
  DynamicRouteHref,
  RouteParamsMap,
} from "./types";

export type {
  ScannedRoute,
  RouteCodegenConfig,
  RouteMeta,
  StringifyValues,
  SearchParamsValidator,
  ParamsValidator,
  StaticRouteValidator,
  DynamicRouteValidator,
  ServerComponent,
  ClientComponent,
  StaticRouteOptionsWithValidator,
  StaticRouteOptions,
  DynamicRouteOptionsWithValidator,
  DynamicRouteOptions,
} from "./route-meta";

export type { RouteConfig, RouteComponent } from "./create-route";

export type {
  RouteInfo,
  FullRouteInfo,
  PathnameRouteInfo,
  FullPathnameRouteInfo,
  RouteOptions,
} from "./utils";

// Functions
export { createRouteConfig } from "./route-meta";
export { createRoute, createDynamicRoute } from "./create-route";

export {
  path,
  matchDynamicRoute,
  extractParams,
  getAllRoutes,
  getRoute,
  getRouteByPathname,
  ROUTES,
  ROUTE_INFO,
  ROUTE_CONFIGS,
  DYNAMIC_ROUTE_PATTERNS,
} from "./utils";
`;
}

/**
 * Template for types.ts (init) - empty placeholder
 */
export function typesInitTemplate(): string {
  return `${getHeaderComment()}
/** Static routes (no params required) */
export type StaticRouteHref = string;

/** Dynamic routes (params required) */
export type DynamicRouteHref = string;

/** All route hrefs */
export type RouteHref = StaticRouteHref | DynamicRouteHref;

/** Params type map for dynamic routes */
export interface RouteParamsMap {
  [key: string]: Record<string, string>;
}
`;
}

/**
 * Template for routes.ts (init) - empty placeholder
 */
export function routesInitTemplate(): string {
  return `${getHeaderComment()}
import type { RouteConfig } from "./create-route";
import type { RouteHref, DynamicRouteHref } from "./types";
import type { RouteInfo } from "./utils";

/** All available routes */
export const ROUTES = [] as const satisfies readonly RouteHref[];

/** Static route info map */
export const ROUTE_INFO = {} as { [K in RouteHref]: RouteInfo<K> };

/** Dynamic import getters for route configs */
export const ROUTE_CONFIGS = {} as { [K in RouteHref]: () => Promise<RouteConfig | undefined> };

/** Dynamic route patterns for runtime matching */
export const DYNAMIC_ROUTE_PATTERNS: Array<{
  pattern: RegExp;
  href: DynamicRouteHref;
}> = [];
`;
}

// ============================================
// Generate Templates (Dynamic files - regenerated on route changes)
// ============================================

/**
 * Template for types.ts (generate)
 */
export function typesTemplate(params: {
  staticHrefUnion: string;
  dynamicHrefUnion: string;
  paramsMap: string;
}): string {
  const { staticHrefUnion, dynamicHrefUnion, paramsMap } = params;

  return `${getHeaderComment()}
/** Static routes (no params required) */
export type StaticRouteHref =
${staticHrefUnion || "  | never"};

/** Dynamic routes (params required) */
export type DynamicRouteHref =
${dynamicHrefUnion || "  | never"};

/** All route hrefs */
export type RouteHref = StaticRouteHref | DynamicRouteHref;

/** Params type map for dynamic routes */
export interface RouteParamsMap {
${paramsMap || "  // No dynamic routes"}
}
`;
}

interface RouteInput {
  routePath: string;
  importPath: string;
  params: string[];
  isStatic: boolean;
}

/**
 * Template for routes.ts (generate) - dynamic route data
 */
export function routesTemplate(params: {
  dynamicPatterns: string;
  staticRoutes: RouteInput[];
  dynamicRoutes: RouteInput[];
}): string {
  const { dynamicPatterns, staticRoutes, dynamicRoutes } = params;

  const allRoutes = [...staticRoutes, ...dynamicRoutes];
  const routesArrayLiteral = allRoutes.length > 0
    ? allRoutes.map((r) => `  "${r.routePath}" as const`).join(",\n")
    : "";

  const routeConfigsLiteral = allRoutes
    .map((r) => `  "${r.routePath}": () => import("${r.importPath}").then(m => (m.default as RouteComponent | undefined)?._routeConfig)`)
    .join(",\n");

  const routeInfoLiteral = allRoutes
    .map((r) => {
      const paramsStr = JSON.stringify(r.params);
      return `  "${r.routePath}": {
    href: "${r.routePath}",
    isStatic: ${r.isStatic},
    params: ${paramsStr},
  } as RouteInfo<"${r.routePath}">`;
    })
    .join(",\n");

  // Only import DynamicRouteHref if there are dynamic routes
  const hasDynamicRoutes = dynamicRoutes.length > 0;
  const typesImport = hasDynamicRoutes
    ? `import type { RouteHref, DynamicRouteHref } from "./types";`
    : `import type { RouteHref } from "./types";`;

  return `${getHeaderComment()}
import type { RouteConfig, RouteComponent } from "./create-route";
${typesImport}
import type { RouteInfo } from "./utils";

/** All available routes */
export const ROUTES = [
${routesArrayLiteral}
] as const satisfies readonly RouteHref[];

/** Static route info map */
export const ROUTE_INFO: { [K in RouteHref]: RouteInfo<K> } = {
${routeInfoLiteral}
};

/** Dynamic import getters for route configs */
export const ROUTE_CONFIGS: { [K in RouteHref]: () => Promise<RouteConfig | undefined> } = {
${routeConfigsLiteral}
};

/** Dynamic route patterns for runtime matching */
export const DYNAMIC_ROUTE_PATTERNS${hasDynamicRoutes ? `: Array<{
  pattern: RegExp;
  href: DynamicRouteHref;
}>` : ""} = [
${dynamicPatterns}
]${hasDynamicRoutes ? "" : " as const"};
`;
}
