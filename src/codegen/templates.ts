/**
 * Code generation templates for route files
 */

export function getHeaderComment(): string {
  return `// Auto-generated by next-typed-codegen-route. Do not edit.
// Generated at: ${new Date().toISOString()}
`;
}

/**
 * Template for types.ts
 */
export function typesTemplate(params: {
  staticHrefUnion: string;
  dynamicHrefUnion: string;
  paramsMap: string;
}): string {
  const { staticHrefUnion, dynamicHrefUnion, paramsMap } = params;

  return `${getHeaderComment()}
/** Static routes (no params required) */
export type StaticRouteHref =
${staticHrefUnion || "  | never"};

/** Dynamic routes (params required) */
export type DynamicRouteHref =
${dynamicHrefUnion || "  | never"};

/** All route hrefs */
export type RouteHref = StaticRouteHref | DynamicRouteHref;

/** Params type map for dynamic routes */
export interface RouteParamsMap {
${paramsMap || "  // No dynamic routes"}
}
`;
}

/**
 * Template for utils.ts
 */
export function utilsTemplate(params: { dynamicPatterns: string }): string {
  const { dynamicPatterns } = params;

  return `${getHeaderComment()}
import type {
  RouteHref,
  StaticRouteHref,
  DynamicRouteHref,
  RouteParamsMap,
} from "./types";

/** Dynamic route patterns for runtime matching */
export const DYNAMIC_ROUTE_PATTERNS: Array<{
  pattern: RegExp;
  href: DynamicRouteHref;
}> = [
${dynamicPatterns}
];

/**
 * Type-safe path builder
 *
 * @example
 * // Static route
 * path("/service/karavan")
 * // => "/service/karavan"
 *
 * // Dynamic route - params type is automatically inferred
 * path("/service/karavan/cluster/[cluster-name]/topic/[topic-name]", {
 *   "cluster-name": "prod",
 *   "topic-name": "events",
 * })
 * // => "/service/karavan/cluster/prod/topic/events"
 */
export function path<T extends StaticRouteHref>(route: T): string;
export function path<T extends DynamicRouteHref>(
  route: T,
  params: RouteParamsMap[T]
): string;
export function path(route: RouteHref, params?: Record<string, string>): string {
  if (!params) return route;

  return route.replace(/\\[([^\\]]+)\\]/g, (_, key) => {
    const value = params[key];
    if (value === undefined) {
      throw new Error(\`Missing param: \${key} for route: \${route}\`);
    }
    return encodeURIComponent(value);
  });
}

/**
 * Find matching dynamic route pattern from actual URL path
 *
 * @example
 * matchDynamicRoute("/service/karavan/cluster/prod/topic/events")
 * // => "/service/karavan/cluster/[cluster-name]/topic/[topic-name]"
 */
export function matchDynamicRoute(pathname: string): DynamicRouteHref | null {
  for (const { pattern, href } of DYNAMIC_ROUTE_PATTERNS) {
    if (pattern.test(pathname)) {
      return href;
    }
  }
  return null;
}

/**
 * Extract dynamic parameters from actual URL path
 *
 * @example
 * extractParams(
 *   "/service/karavan/cluster/prod/topic/events",
 *   "/service/karavan/cluster/[cluster-name]/topic/[topic-name]"
 * )
 * // => { "cluster-name": "prod", "topic-name": "events" }
 */
export function extractParams(
  pathname: string,
  pattern: DynamicRouteHref
): Record<string, string> | null {
  const patternEntry = DYNAMIC_ROUTE_PATTERNS.find((p) => p.href === pattern);
  if (!patternEntry) return null;

  const match = pathname.match(patternEntry.pattern);
  if (!match) return null;

  // Extract param keys from pattern
  const paramKeys = pattern.match(/\\[([^\\]]+)\\]/g);
  if (!paramKeys) return {};

  const result: Record<string, string> = {};
  paramKeys.forEach((key, index) => {
    const paramName = key.slice(1, -1);
    result[paramName] = decodeURIComponent(match[index + 1]);
  });

  return result;
}
`;
}

/**
 * Template for index.ts
 */
export function indexTemplate(): string {
  return `${getHeaderComment()}
export type {
  RouteHref,
  StaticRouteHref,
  DynamicRouteHref,
  RouteParamsMap,
} from "./types";

export {
  path,
  matchDynamicRoute,
  extractParams,
  DYNAMIC_ROUTE_PATTERNS,
} from "./utils";
`;
}
